name: CI/CD for workflow backend

# to run the workflow manualy
on:
  workflow_dispatch:
# uncomment these lines if you want to run the workflow automatiqualy in the dev branche   
# on:
#   push:
#     branches:
#       - dev
#   pull_request:
#     branches:
#       - dev
      
env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  TAG_NAME: 0.1


jobs:
  test:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.x'

      - name: Set PYTHONPATH
        run: echo "PYTHONPATH=$(pwd)" >> $GITHUB_ENV

      - name: Install dependencies
        run: |
          pip install -r requirements.txt

      # - name: Lint with flake8
      #   run: |
      #     pip install flake8
      #     flake8 --max-line-length=88 --ignore=W391 ./

      # - name: Run security tests with bandit
      #   run: |
      #     pip install bandit
      #     bandit -r ./

      # - name: Install pytest-cov
      #   run: |
      #     pip install pytest-cov

      # - name: Run tests with coverage
      #   run: |
      #     pytest --cov=chat --cov-fail-under=80 ./tests/

      # - name: Generate HTML coverage report
      #   run: |
      #     pytest --cov=chat --cov-report=html ./tests/

      # - name: Store coverage report
      #   uses: actions/upload-artifact@v4  # Version mise à jour
      #   with:
      #     name: coverage-report
      #     path: htmlcov/
          
  # Job de construction
  build:
    runs-on: ubuntu-latest # Utilisation d'un runner personnalisé pour ce job. Ce runner est une machine virtuelle (VM) configurée avec Debian 12.

    needs: test # Ce job est dépendant du job de test, il ne s'exécute que si le job de test réussit

    permissions: # Définit les permissions accordées au GITHUB_TOKEN pour les actions dans ce job.
      contents: read # Ces permissions contrôlent ce que le GITHUB_TOKEN peut faire dans ce job spécifique,
      packages: write # limitant ou autorisant des actions telles que la lecture du dépôt, la publication de packages,
      attestations: write # et l'authentification avec des services externes.
      id-token: write

    steps: # Liste des étapes à exécuter dans ce job
      - name: Checkout code # Etape pour la récupération du code source du dépôt
        uses: actions/checkout@v3 # Action réutilisable pour checker le code du dépôt GitHub

      - name: Log in to GitHub Container Registry # Connexion au registre de conteneurs GitHub
        run: echo "${{ secrets.GITHUB_TOKEN }}" | docker login  ${{ env.REGISTRY }} -u ${{ github.actor }} --password-stdin
      # Utilisation du token GitHub pour se connecter au registre de conteneurs

      - name: Build Docker image # Construction de l'image Docker
        run: |
          docker build -t ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ env.TAG_NAME }} .

      - name: Push Docker image # Pousser l'image Docker vers GitHub Container Registry
        run: |
          docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ env.TAG_NAME }}
  # Job de déploiement
  deploy:
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Setup SSH Key
        run: |
          mkdir -p ~/.ssh
          install -m 600 -D /dev/null ~/.ssh/id_rsa
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.REMOTE_HOST }} >> ~/.ssh/known_hosts
        shell: bash
  
      - name: Install sshpass
        run: sudo apt-get install -y sshpass
  
      - name: Deploy to remote server
        run: |
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -o StrictHostKeyChecking=no "$REMOTE_USER@$REMOTE_HOST" <<EOF
          echo "${{ secrets.GITHUB_TOKEN }}" | docker login ${{ env.REGISTRY }} -u ${{ github.actor }} --password-stdin
          docker stop backend-ufs-app || true
          docker rm backend-ufs-app || true
          docker rmi ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ env.TAG_NAME }} || true
          docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ env.TAG_NAME }}
          docker run -d -p 8000:8000 --name backend-ufs-app \
            -e DJANGO_SECRET_KEY='${{ secrets.DJANGO_SECRET_KEY }}' \
            -e DJANGO_DEBUG=${{ secrets.DJANGO_DEBUG }} \
            -e DJANGO_ALLOWED_HOSTS='${{ secrets.DJANGO_ALLOWED_HOSTS }}' \
            -e DB_NAME='${{ secrets.DB_NAME }}' \
            -e DB_USER='${{ secrets.DB_USER }}' \
            -e DB_PASSWORD='${{ secrets.DB_PASSWORD }}' \
            -e DB_HOST='${{ secrets.DB_HOST }}' \
            -e DB_PORT=${{ secrets.DB_PORT }} \
            -e EMAIL_BACKEND='${{ secrets.EMAIL_BACKEND }}' \
            -e EMAIL_HOST='${{ secrets.EMAIL_HOST }}' \
            -e EMAIL_PORT=${{ secrets.EMAIL_PORT }} \
            -e EMAIL_USE_TLS=${{ secrets.EMAIL_USE_TLS }} \
            -e EMAIL_HOST_USER='${{ secrets.EMAIL_HOST_USER }}' \
            -e EMAIL_HOST_PASSWORD='${{ secrets.EMAIL_HOST_PASSWORD }}' \
            -e DEFAULT_FROM_EMAIL='${{ secrets.DEFAULT_FROM_EMAIL }}' \
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ env.TAG_NAME }}
          EOF
        shell: bash
        env:
          REMOTE_USER: ${{ secrets.REMOTE_USER }}
          REMOTE_HOST: ${{ secrets.REMOTE_HOST }}
